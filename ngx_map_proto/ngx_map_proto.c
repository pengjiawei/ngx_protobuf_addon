/* Generated by protobuf-nginx 1.1 - DO NOT EDIT */

#include <ngx_protobuf.h>
#include "ngx_map_proto.h"

/* MapCell field descriptors */

ngx_protobuf_field_descriptor_t
ngx_map_cell_x = {
    ngx_string("x"),
    1,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_REQUIRED,
    NGX_PROTOBUF_TYPE_UINT32,
    sizeof(uint32_t),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

ngx_protobuf_field_descriptor_t
ngx_map_cell_y = {
    ngx_string("y"),
    2,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_REQUIRED,
    NGX_PROTOBUF_TYPE_UINT32,
    sizeof(uint32_t),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

ngx_protobuf_field_descriptor_t
ngx_map_cell_value = {
    ngx_string("value"),
    3,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_OPTIONAL,
    NGX_PROTOBUF_TYPE_ENUM,
    sizeof(ngx_map_cell_value_e),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

/* Map field descriptors */

ngx_protobuf_field_descriptor_t
ngx_map_width = {
    ngx_string("width"),
    1,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_REQUIRED,
    NGX_PROTOBUF_TYPE_UINT32,
    sizeof(uint32_t),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

ngx_protobuf_field_descriptor_t
ngx_map_height = {
    ngx_string("height"),
    2,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_REQUIRED,
    NGX_PROTOBUF_TYPE_UINT32,
    sizeof(uint32_t),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

ngx_protobuf_field_descriptor_t
ngx_map_mapCell = {
    ngx_string("mapCell"),
    3,
    NGX_PROTOBUF_WIRETYPE_LENGTH_DELIMITED,
    NGX_PROTOBUF_LABEL_REPEATED,
    NGX_PROTOBUF_TYPE_MESSAGE,
    sizeof(ngx_map_cell_t),
    0,
    (ngx_protobuf_pack_pt)
    ngx_map_cell__pack,
    (ngx_protobuf_unpack_pt)
    ngx_map_cell__unpack,
    (ngx_protobuf_size_pt)
    ngx_map_cell__size
};

static ngx_protobuf_module_t
ngx_map_proto_module_ctx = {
    NULL
};

ngx_module_t ngx_map_proto_module = {
    NGX_MODULE_V1,
    &ngx_map_proto_module_ctx,
    NULL,
    NGX_PROTOBUF_MODULE,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NGX_MODULE_V1_PADDING
};

/* MapCell message methods */

ngx_int_t
ngx_map_cell__is_initialized(
    ngx_map_cell_t *obj)
{
    return (ngx_map_cell__has_x(obj)
        && ngx_map_cell__has_y(obj));
}

ngx_int_t
ngx_map_cell__unpack(
    ngx_map_cell_t *obj,
    ngx_protobuf_context_t *ctx)
{
    u_char      **pos = &ctx->buffer.pos;
    u_char       *end = ctx->buffer.last;
    uint32_t      header;
    uint32_t      field;
    uint32_t      wire;
    ngx_int_t     rc;

    while (*pos < end) {
        if (ngx_protobuf_read_uint32(pos, end, &header) != NGX_OK) {
            return NGX_ABORT;
        }

        if (*pos >= end) {
            return NGX_ABORT;
        }

        field = header >> 3;
        wire = header & 0x07;

        switch (field) {
        case 1: /* MapCell.x */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    &obj->x) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_x = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        case 2: /* MapCell.y */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    &obj->y) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_y = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        case 3: /* MapCell.value */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    (uint32_t *)&obj->value) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_value = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        default:
            rc = ngx_protobuf_unpack_unknown_field(field, wire, ctx,
                &obj->__unknown);
            if (rc != NGX_OK) {
                return rc;
            }
            break;
        }
    }

    return NGX_OK;
}

size_t
ngx_map_cell__size(
     ngx_map_cell_t *obj)
{
    size_t      size = 0;
    ngx_uint_t  i;

    if (obj->__has_x) {
        size += ngx_protobuf_size_uint32_field(obj->x, 1);
    }
    if (obj->__has_y) {
        size += ngx_protobuf_size_uint32_field(obj->y, 2);
    }
    if (obj->__has_value) {
        size += ngx_protobuf_size_uint32_field(obj->value, 3);
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t *unk = obj->__unknown->elts;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            size += ngx_protobuf_size_unknown_field(unk + i);
        }
    }

    return size;
}

ngx_int_t
ngx_map_cell__pack(
    ngx_map_cell_t *obj,
    ngx_protobuf_context_t *ctx)
{
    size_t     size = ngx_map_cell__size(obj);
    ngx_int_t  rc;

    if (size == 0) {
        return NGX_OK;
    }

    if (ctx->buffer.pos + size > ctx->buffer.last) {
        return NGX_ABORT;
    }

    if (obj->__has_x) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->x,
            1);
    }
    if (obj->__has_y) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->y,
            2);
    }
    if (obj->__has_value) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->value,
            3);
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t  *unk = obj->__unknown->elts;
        ngx_uint_t                     i;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            rc = ngx_protobuf_pack_unknown_field(unk + i, ctx);
            if (rc != NGX_OK) {
                return rc;
            }
        }
    }

    return NGX_OK;
}

/* Map field methods */

ngx_map_cell_t *
ngx_map__add__mapCell(
    ngx_map_t *obj,
    ngx_pool_t *pool)
{
    ngx_map_cell_t *ret;

    ret = ngx_protobuf_push_array(&obj->mapCell, pool,
        sizeof(ngx_map_cell_t));
    if (ret != NULL) {
        obj->__has_mapCell = 1;
    }

    return ret;
}

/* Map message methods */

ngx_int_t
ngx_map__is_initialized(
    ngx_map_t *obj)
{
    return (ngx_map__has_width(obj)
        && ngx_map__has_height(obj));
}

static ngx_int_t
ngx_map__unpack_mapCell(
    ngx_map_t *obj,
    ngx_protobuf_context_t *ctx,
    size_t len)
{
    ngx_map_cell_t  *fptr;
    u_char          *end0;
    u_char          *end;
    ngx_int_t        rc;

    if (len == 0) {
        return NGX_OK;
    }

    end = ctx->buffer.pos + len;
    if (end > ctx->buffer.last) {
        return NGX_ABORT;
    }

    fptr = ngx_map__add__mapCell(obj, ctx->pool);
    if (fptr == NULL) {
        return NGX_ERROR;
    }

    end0 = ctx->buffer.last;
    ctx->buffer.last = end;
    rc = ngx_map_cell__unpack(fptr, ctx);
    ctx->buffer.last = end0;

    if (rc == NGX_OK) {
        obj->__has_mapCell = 1;
    }

    return rc;
}

ngx_int_t
ngx_map__unpack(
    ngx_map_t *obj,
    ngx_protobuf_context_t *ctx)
{
    u_char      **pos = &ctx->buffer.pos;
    u_char       *end = ctx->buffer.last;
    uint32_t      header;
    uint32_t      field;
    uint32_t      wire;
    uint32_t      mlen;
    ngx_int_t     rc;

    while (*pos < end) {
        if (ngx_protobuf_read_uint32(pos, end, &header) != NGX_OK) {
            return NGX_ABORT;
        }

        if (*pos >= end) {
            return NGX_ABORT;
        }

        field = header >> 3;
        wire = header & 0x07;

        switch (field) {
        case 1: /* Map.width */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    &obj->width) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_width = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        case 2: /* Map.height */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    &obj->height) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_height = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        case 3: /* Map.mapCell */
            if (wire == NGX_PROTOBUF_WIRETYPE_LENGTH_DELIMITED) {
                if (ngx_protobuf_read_uint32(pos, end, &mlen) != NGX_OK) {
                    return NGX_ABORT;
                }
                rc = ngx_map__unpack_mapCell(obj, ctx, mlen);
                if (rc != NGX_OK) {
                    return rc;
                }
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        default:
            rc = ngx_protobuf_unpack_unknown_field(field, wire, ctx,
                &obj->__unknown);
            if (rc != NGX_OK) {
                return rc;
            }
            break;
        }
    }

    return NGX_OK;
}

size_t
ngx_map__size(
     ngx_map_t *obj)
{
    size_t      size = 0;
    size_t      n;
    ngx_uint_t  i;

    if (obj->__has_width) {
        size += ngx_protobuf_size_uint32_field(obj->width, 1);
    }
    if (obj->__has_height) {
        size += ngx_protobuf_size_uint32_field(obj->height, 2);
    }
    if (obj->__has_mapCell
        && obj->mapCell != NULL
        && obj->mapCell->nelts > 0)
    {
        ngx_map_cell_t *vals = obj->mapCell->elts;

        for (i = 0; i < obj->mapCell->nelts; ++i) {
            n = ngx_map_cell__size(vals + i);
            size += ngx_protobuf_size_message_field(n, 3);
        }
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t *unk = obj->__unknown->elts;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            size += ngx_protobuf_size_unknown_field(unk + i);
        }
    }

    return size;
}

ngx_int_t
ngx_map__pack(
    ngx_map_t *obj,
    ngx_protobuf_context_t *ctx)
{
    size_t     size = ngx_map__size(obj);
    size_t     n;
    ngx_int_t  rc;

    if (size == 0) {
        return NGX_OK;
    }

    if (ctx->buffer.pos + size > ctx->buffer.last) {
        return NGX_ABORT;
    }

    if (obj->__has_width) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->width,
            1);
    }
    if (obj->__has_height) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->height,
            2);
    }
    if (obj->__has_mapCell
        && obj->mapCell != NULL
        && obj->mapCell->nelts > 0)
    {
        ngx_map_cell_t *vals = obj->mapCell->elts;
        ngx_uint_t i;

        for (i = 0; i < obj->mapCell->nelts; ++i) {
            n = ngx_map_cell__size(vals + i);
            ctx->buffer.pos = ngx_protobuf_write_message_header(
                ctx->buffer.pos, n, 3);
            ngx_map_cell__pack(vals + i, ctx);
        }
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t  *unk = obj->__unknown->elts;
        ngx_uint_t                     i;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            rc = ngx_protobuf_pack_unknown_field(unk + i, ctx);
            if (rc != NGX_OK) {
                return rc;
            }
        }
    }

    return NGX_OK;
}

