/* Generated by protobuf-nginx 1.1 - DO NOT EDIT */
extern "C"{
#include <ngx_protobuf.h>
#include "ngx_plan_proto.h"
}
/* Point field descriptors */

ngx_protobuf_field_descriptor_t
ngx_point_x = {
    ngx_string("x"),
    1,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_REQUIRED,
    NGX_PROTOBUF_TYPE_UINT32,
    sizeof(uint32_t),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

ngx_protobuf_field_descriptor_t
ngx_point_y = {
    ngx_string("y"),
    2,
    NGX_PROTOBUF_WIRETYPE_VARINT,
    NGX_PROTOBUF_LABEL_REQUIRED,
    NGX_PROTOBUF_TYPE_UINT32,
    sizeof(uint32_t),
    0,
    (ngx_protobuf_pack_pt)
    NULL,
    (ngx_protobuf_unpack_pt)
    NULL,
    (ngx_protobuf_size_pt)
    NULL
};

/* Plan field descriptors */

ngx_protobuf_field_descriptor_t
ngx_plan_point = {
    ngx_string("point"),
    1,
    NGX_PROTOBUF_WIRETYPE_LENGTH_DELIMITED,
    NGX_PROTOBUF_LABEL_REPEATED,
    NGX_PROTOBUF_TYPE_MESSAGE,
    sizeof(ngx_point_t),
    0,
    (ngx_protobuf_pack_pt)
    ngx_point__pack,
    (ngx_protobuf_unpack_pt)
    ngx_point__unpack,
    (ngx_protobuf_size_pt)
    ngx_point__size
};

static ngx_protobuf_module_t
ngx_plan_proto_module_ctx = {
    NULL
};

ngx_module_t ngx_plan_proto_module = {
    NGX_MODULE_V1,
    &ngx_plan_proto_module_ctx,
    NULL,
    NGX_PROTOBUF_MODULE,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NGX_MODULE_V1_PADDING
};

/* Point message methods */

ngx_int_t
ngx_point__is_initialized(
    ngx_point_t *obj)
{
    return (ngx_point__has_x(obj)
        && ngx_point__has_y(obj));
}

ngx_int_t
ngx_point__unpack(
    ngx_point_t *obj,
    ngx_protobuf_context_t *ctx)
{
    u_char      **pos = &ctx->buffer.pos;
    u_char       *end = ctx->buffer.last;
    uint32_t      header;
    uint32_t      field;
    uint32_t      wire;
    ngx_int_t     rc;

    while (*pos < end) {
        if (ngx_protobuf_read_uint32(pos, end, &header) != NGX_OK) {
            return NGX_ABORT;
        }

        if (*pos >= end) {
            return NGX_ABORT;
        }

        field = header >> 3;
        wire = header & 0x07;

        switch (field) {
        case 1: /* Point.x */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    &obj->x) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_x = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        case 2: /* Point.y */
            if (wire == NGX_PROTOBUF_WIRETYPE_VARINT) {
                if (ngx_protobuf_read_uint32(pos, end,
                    &obj->y) != NGX_OK)
                {
                    return NGX_ABORT;
                }
                obj->__has_y = 1;
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        default:
            rc = ngx_protobuf_unpack_unknown_field(field, wire, ctx,
                &obj->__unknown);
            if (rc != NGX_OK) {
                return rc;
            }
            break;
        }
    }

    return NGX_OK;
}

size_t
ngx_point__size(
     ngx_point_t *obj)
{
    size_t      size = 0;
    ngx_uint_t  i;

    if (obj->__has_x) {
        size += ngx_protobuf_size_uint32_field(obj->x, 1);
    }
    if (obj->__has_y) {
        size += ngx_protobuf_size_uint32_field(obj->y, 2);
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t *unk = obj->__unknown->elts;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            size += ngx_protobuf_size_unknown_field(unk + i);
        }
    }

    return size;
}

ngx_int_t
ngx_point__pack(
    ngx_point_t *obj,
    ngx_protobuf_context_t *ctx)
{
    size_t     size = ngx_point__size(obj);
    ngx_int_t  rc;

    if (size == 0) {
        return NGX_OK;
    }

    if (ctx->buffer.pos + size > ctx->buffer.last) {
        return NGX_ABORT;
    }

    if (obj->__has_x) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->x,
            1);
    }
    if (obj->__has_y) {
        ctx->buffer.pos = ngx_protobuf_write_uint32_field(
            ctx->buffer.pos,
            obj->y,
            2);
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t  *unk = obj->__unknown->elts;
        ngx_uint_t                     i;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            rc = ngx_protobuf_pack_unknown_field(unk + i, ctx);
            if (rc != NGX_OK) {
                return rc;
            }
        }
    }

    return NGX_OK;
}

/* Plan field methods */

ngx_point_t *
ngx_plan__add__point(
    ngx_plan_t *obj,
    ngx_pool_t *pool)
{
    ngx_point_t *ret;

    ret = ngx_protobuf_push_array(&obj->point, pool,
        sizeof(ngx_point_t));
    if (ret != NULL) {
        obj->__has_point = 1;
    }

    return ret;
}

/* Plan message methods */

ngx_int_t
ngx_plan__is_initialized(
    ngx_plan_t *obj)
{
    return 1; /* no required fields */
}

static ngx_int_t
ngx_plan__unpack_point(
    ngx_plan_t *obj,
    ngx_protobuf_context_t *ctx,
    size_t len)
{
    ngx_point_t  *fptr;
    u_char       *end0;
    u_char       *end;
    ngx_int_t     rc;

    if (len == 0) {
        return NGX_OK;
    }

    end = ctx->buffer.pos + len;
    if (end > ctx->buffer.last) {
        return NGX_ABORT;
    }

    fptr = ngx_plan__add__point(obj, ctx->pool);
    if (fptr == NULL) {
        return NGX_ERROR;
    }

    end0 = ctx->buffer.last;
    ctx->buffer.last = end;
    rc = ngx_point__unpack(fptr, ctx);
    ctx->buffer.last = end0;

    if (rc == NGX_OK) {
        obj->__has_point = 1;
    }

    return rc;
}

ngx_int_t
ngx_plan__unpack(
    ngx_plan_t *obj,
    ngx_protobuf_context_t *ctx)
{
    u_char      **pos = &ctx->buffer.pos;
    u_char       *end = ctx->buffer.last;
    uint32_t      header;
    uint32_t      field;
    uint32_t      wire;
    uint32_t      mlen;
    ngx_int_t     rc;

    while (*pos < end) {
        if (ngx_protobuf_read_uint32(pos, end, &header) != NGX_OK) {
            return NGX_ABORT;
        }

        if (*pos >= end) {
            return NGX_ABORT;
        }

        field = header >> 3;
        wire = header & 0x07;

        switch (field) {
        case 1: /* Plan.point */
            if (wire == NGX_PROTOBUF_WIRETYPE_LENGTH_DELIMITED) {
                if (ngx_protobuf_read_uint32(pos, end, &mlen) != NGX_OK) {
                    return NGX_ABORT;
                }
                rc = ngx_plan__unpack_point(obj, ctx, mlen);
                if (rc != NGX_OK) {
                    return rc;
                }
            } else {
                if (ngx_protobuf_skip(pos, end, wire) != NGX_OK) {
                    return NGX_ABORT;
                }
            }
            break;
        default:
            rc = ngx_protobuf_unpack_unknown_field(field, wire, ctx,
                &obj->__unknown);
            if (rc != NGX_OK) {
                return rc;
            }
            break;
        }
    }

    return NGX_OK;
}

size_t
ngx_plan__size(
     ngx_plan_t *obj)
{
    size_t      size = 0;
    size_t      n;
    ngx_uint_t  i;

    if (obj->__has_point
        && obj->point != NULL
        && obj->point->nelts > 0)
    {
        ngx_point_t *vals = obj->point->elts;

        for (i = 0; i < obj->point->nelts; ++i) {
            n = ngx_point__size(vals + i);
            size += ngx_protobuf_size_message_field(n, 1);
        }
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t *unk = obj->__unknown->elts;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            size += ngx_protobuf_size_unknown_field(unk + i);
        }
    }

    return size;
}

ngx_int_t
ngx_plan__pack(
    ngx_plan_t *obj,
    ngx_protobuf_context_t *ctx)
{
    size_t     size = ngx_plan__size(obj);
    size_t     n;
    ngx_int_t  rc;

    if (size == 0) {
        return NGX_OK;
    }

    if (ctx->buffer.pos + size > ctx->buffer.last) {
        return NGX_ABORT;
    }

    if (obj->__has_point
        && obj->point != NULL
        && obj->point->nelts > 0)
    {
        ngx_point_t *vals = obj->point->elts;
        ngx_uint_t i;

        for (i = 0; i < obj->point->nelts; ++i) {
            n = ngx_point__size(vals + i);
            ctx->buffer.pos = ngx_protobuf_write_message_header(
                ctx->buffer.pos, n, 1);
            ngx_point__pack(vals + i, ctx);
        }
    }

    if (obj->__unknown != NULL
        && obj->__unknown->elts != NULL
        && obj->__unknown->nelts > 0)
    {
        ngx_protobuf_unknown_field_t  *unk = obj->__unknown->elts;
        ngx_uint_t                     i;

        for (i = 0; i < obj->__unknown->nelts; ++i) {
            rc = ngx_protobuf_pack_unknown_field(unk + i, ctx);
            if (rc != NGX_OK) {
                return rc;
            }
        }
    }

    return NGX_OK;
}

